"""
helper functions
----------------
    - load_data_json
    - update_data_json
    - talk_to_cli
    - user_custom_fee
"""

import json
from random import randint
from subprocess import Popen, PIPE

import errors

from bitcoinutils.keys import P2pkhAddress, PrivateKey, PublicKey
from bitcoinutils.constants import TYPE_RELATIVE_TIMELOCK
from bitcoinutils.transactions import Sequence


def load_data_json(priv=False, pub=False, pub_hash=False, timelock_csv=False, 
    timelock_tx=False, timelock_log=False, p2pk=False):
    """loads parameters used to create P2SH address and spending transactions
    from the data.json file - initiates/converts applicable objects/data

    returns : dict of data for the Attributes specified
        - e.g {'priv_key': object, 'pub': object, 'pub_hash': 'string'}
    """

    # reads user data from data.json
    with open('data.json', 'r') as json_file:
        data = json.load(json_file)
        usr_inputs = data['csv_timelock']['inputs']

    # initiates key objects
    if priv or pub or pub_hash:
        usr_priv = usr_inputs['priv_key']
        usr_pub = usr_inputs['pub_key']
        if priv and not usr_priv:
            errors.missing_data('private key')
        elif usr_priv:
            priv_key = PrivateKey.from_wif(usr_priv)
            pub_key = priv_key.get_public_key()
        elif usr_pub:
            pub_key = PublicKey.from_hex(usr_pub)
        else:
            # prints error msg & raises systemExit
            errors.missing_data('public key')  
    
    # loads timelock condition and converts format
    if timelock_csv or timelock_tx or timelock_log:
        lock_height = usr_inputs['block_lock']
        if lock_height:
            seq = Sequence(TYPE_RELATIVE_TIMELOCK, lock_height)
            timelock_script = seq.for_script()
            timelock_txin = seq.for_input_sequence()
        else:
            # prints error msg & raises systemExit
            errors.missing_data('timelock period')     

    # initaites P2pkhAddress object
    if p2pk:
        address = usr_inputs['p2pkh_address']
        if address:
            p2pkh_address = P2pkhAddress.from_address(address)
        else:
            # prints error msg & raises systemExit
            errors.missing_data('P2PKH address')

    # fills return outputs with specified data from func arguments
    outputs = {}
    if priv:
        outputs['priv_key'] = priv_key
    if pub:
        outputs['pub_key'] = pub_key
    if pub_hash:
        outputs['pub_key_hash'] = pub_key.to_hash160()
    if timelock_csv:
        outputs['timelock_csv'] = timelock_script
    if timelock_tx:
        outputs['timelock_tx'] = timelock_txin
    if timelock_log:
        outputs['timelock_log'] = lock_height
    if p2pk:
        outputs['p2pk_addr'] = p2pkh_address
    
    return outputs


def update_data_json(inputs={}, outputs={}):
    """updates data.json with outputs generated by the program: 'p2sh_address',
    'csv_hash', 'tx_id', 'tx_signed'

    Attributes
    ----------
    data_outputs : dictionary
        e.g. {'tx_id': '124124', 'p2sh_address': '2egwge...wgweg'}
    data_inputs : dictionary
        e.g. {'priv_key': '2egwge...wgweg', 'timelock': 5}
    """
    # loading json.data as data{dic}
    with open('data.json', 'r') as json_file:
        data = json.load(json_file)

    # inserting data_inputs into data{dic}
    for key in inputs:
        data['csv_timelock']['inputs'][key] = inputs[key]

    # inserting data_ouputs into data{dic}
    for key in outputs:
        data['csv_timelock']['outputs'][key] = outputs[key]

    # updating json.data with updated data{dic}
    with open('data.json', 'w') as json_file:
        json.dump(data, json_file, indent=4) 


def talk_to_cli(command, std=False):
    """uses os communication to send commands to cli/terminal

    Attributes
    ----------
    command : cli command as a string
        e.g. 'bitcoin-cli getnewaddress'
    std : if true, returns output from the terminal

    returns : json of cli output
    """
    prc = Popen(command.split(), stdout=PIPE)
    if std:
        return prc.stdout.read().decode('utf-8').replace('\n', '').replace(' ', '')


def config_data():
    """configures data.json with a priv_key and P2PKH address queried from the
    bitcoin-cli, as well as a random block_lock between 1 - 10
    """
    addr = talk_to_cli('bitcoin-cli getnewaddress', True)
    priv_key = talk_to_cli(f'bitcoin-cli dumpprivkey {addr}', True)
    if len(priv_key) != 52:
        print('\nError: Invalid priv_key from local client, please configure manually\n')
        raise SystemExit
    p2pkh_addr = talk_to_cli('bitcoin-cli getnewaddress "" legacy', True)
    if len(p2pkh_addr) != 34:
        print('\nError: Invalid P2PKH_address from local client, please configure manually\n')
        raise SystemExit

    timelock = randint(1, 20)

    update_data_json(inputs={'priv_key': priv_key, 'block_lock': timelock, 
        'p2pkh_address': p2pkh_addr})
    print('\n Configured data.json')
    print(' -> priv_key:', priv_key)
    print(' -> p2pkh_addr:', p2pkh_addr)
    print(' -> block_lock:', timelock, 'blocks\n')


def user_custom_fee(fee, p2sh_balance):
    """called if estimated fee of p2sh spending transaction is larger than the
    balance of the p2sh address. Enables the user to quit the program to add
    more balance to the p2sh, or to specify a custom feee.

    Attributes
    ----------
    fee : float
        estimated fee from program
    p2sh_balance : float
        balance of p2sh address

    returns : c_fee (custom fee set by user)
        - or raises SystemExit if user chooses so
    """
    errors.estimated_fee_2_large(fee, p2sh_balance)  # prints error msg & continues
    while True:
        print('Enter: [q] to exit  |  [float] for custom BTC fee, e.g. 0.00001')
        usr_r = input()
        if usr_r.lower() == 'q':
            raise SystemExit
        else:
            try:
                c_fee = round(float(usr_r), 8)
                if c_fee < p2sh_balance:
                    return c_fee
                else:
                    errors.custom_fee_2_large(c_fee, p2sh_balance) 
                    # prints error msg & loops again
            except ValueError:
                print('No valid input prvoided!')
