"""
main functions
--------------
    - create_csv_script_p2sh
    - create_csv_spending_transaction

helper functions
----------------
    - load_data_json
    - update_data_json
    - talk_to_cli
    - user_custom_fee
"""
# importing standard library modules
import os, sys, json
from time import sleep
from subprocess import Popen, PIPE
# importing project modules
try:
    import requests
    from bitcoinutils.keys import P2pkhAddress, P2shAddress, PrivateKey, PublicKey
    from bitcoinutils.transactions import Transaction, TxInput, TxOutput, Sequence
    from bitcoinutils.constants import TYPE_RELATIVE_TIMELOCK
    from bitcoinutils.script import Script
    from bitcoinutils.setup import setup
except ModuleNotFoundError as e:
        print('\n', e, '\n')
        print('\nError: project venv not activated!')
        print('Please setup & activate venv as follows:')
        print(' - setup:    $ python3 setup.py')
        print(' - activate: $ source ./venv/bin/activate\n')
        raise SystemExit


def load_data_json(priv=False, pub=False, pub_hash=False,
    timelock_csv=False, timelock_tx=False, timelock_log=False, p2pk=False):
    """loads parameters used to create P2SH address and spending transactions
    from the data.json file - initiates/converts applicable objects/data

    returns : dict of data for the Attributes specified
        - e.g {'priv_key': object, 'pub': object, 'pub_hash': 'string'}
    """
    def missing_data(component):
        """helper function called when data.json is not configured fully"""
        print(f'\nError: user {component} not configured!')
        print(f'Please configure {component} in data.json\n')
        raise SystemExit

    # reads user data from data.json
    with open('data.json', 'r') as json_file:
        data = json.load(json_file)
        usr_inputs = data['csv_timelock']['inputs']

    # initiates key objects
    if priv or pub or pub_hash:
        usr_priv = usr_inputs['keys']['priv_key']
        usr_pub = usr_inputs['keys']['pub_key']
        if priv and not usr_priv:
            missing_data('priv key')
        elif usr_priv:
            priv_key = PrivateKey.from_wif(usr_priv)
            pub_key = priv_key.get_public_key()
        elif usr_pub:
            pub_key = PublicKey.from_hex(usr_pub)
        else:
            missing_data('pub key')
    
    # loads timelock condition and converts format
    if timelock_csv or timelock_tx or timelock_log:
        lock_height = usr_inputs['timelock']['block_height']
        if lock_height:
            timelock_str = f'{lock_height} blocks'
            # timelock_txin = lock_height.to_bytes(4,'little').hex()
            # timelock_script = timelock_txin[:4]
            seq = Sequence(TYPE_RELATIVE_TIMELOCK, lock_height)
            timelock_script = seq.for_script()
            timelock_txin = seq.for_input_sequence()
            # TODO testing
        else:
            missing_data('timelock period')        

    # initaites P2pkhAddress object
    if p2pk:
        address = usr_inputs['p2pkh_address']
        if address:
            p2pkh_address = P2pkhAddress.from_address(address)
        else:
            missing_data('p2pkh address')

    # fills return outputs with specified data from func arguments
    outputs = {}
    if priv:
        outputs['priv_key'] = priv_key
    if pub:
        outputs['pub_key'] = pub_key
    if pub_hash:
        outputs['pub_key_hash'] = pub_key.to_hash160()
    if timelock_csv:
        outputs['timelock_csv'] = timelock_script
    if timelock_tx:
        outputs['timelock_tx'] = timelock_txin
    if timelock_log:
        outputs['timelock_log'] = timelock_str
    if p2pk:
        outputs['p2pk_addr'] = p2pkh_address
    
    return outputs


def update_data_json(data_points):
    """updates data.json with outputs generated by the program: 'p2sh_address',
    'csv_hash', 'tx_id', 'tx_signed'

    Attributes
    ----------
    data_points : dictionary
        e.g. {'tx_id': 124124, 'p2sh_address': '2egwge...wgweg'}
    """
    # loading json.data as data{dic}
    with open('data.json', 'r') as json_file:
        data = json.load(json_file)
        usr_outputs = data['csv_timelock']['outputs']

    # inserting data_points into data{dic}
    for key in data_points:
        usr_outputs[key] = data_points[key]

    # updating json.data with updated data{dic}
    with open('data.json', 'w') as json_file:
        json.dump(data, json_file, indent=4) 


def talk_to_cli(command, std=False):
    """uses os communication to send commands to cli/terminal

    Attributes
    ----------
    command : cli command as a string
        e.g. 'bitcoin-cli getnewaddress'
    std : if true, returns output from the terminal

    returns : json of cli output
    """
    prc = Popen(command.split(), stdout=PIPE)
    if std:
        return prc.stdout.read().decode('utf-8').replace('\n', '').replace(' ', '')


def user_custom_fee(fee, p2sh_balance):
    """called if estimated fee of p2sh spending transaction is larger than the
    balance of the p2sh address. Enables the user to quit the program to add
    more balance to the p2sh, or to specify a custom feee.

    Attributes
    ----------
    fee : float
        estimated fee from program
    p2sh_balance : float
        balance of p2sh address

    returns : c_fee (custom fee set by user)
        - or raises System Exit if user chooses so
    """
    print('\nError: estimated fee larger than P2SH balance!')
    print(f'Estimated fee: {fee}  |  Balance: {p2sh_balance}')
    print('Please add balance to P2SH address or set a custom fee.')
    while True:
        print('Enter: [q] to exit  |  [float] for custom BTC fee, e.g. 0.00001')
        usr_r = input()
        if usr_r.lower() == 'q':
            raise SystemExit
        else:
            try:
                c_fee = float(usr_r)
                if c_fee < p2sh_balance:
                    return c_fee
                else:
                    print('Error: custom fee larger than balance!')
                    print(f'Custom fee: {c_fee}  |  Balance: {p2sh_balance}')
            except ValueError:
                print('No valid input prvoided!')


def create_csv_script_p2sh(recreate=False):
    """creates the CSV locking script
    
    Attributes
    ----------
    recreate : boolean
        False (default) -> used when creating new p2sh addr (save and display)
        True -> used when spending from p2sh address (returns objects for TX)
    
    returns
    -------
    if recreate=False (default - used when creating new p2sh addres)
        returns nothing
        - writes p2sh address into data.json
        - displays p2sh address to the user
    if recreate=True (used to recreate script when spending form p2sh address)
        returns csv_script (Script Object), p2sh_addr (P2shAddress Object)
    """
    # load csv script data (pub_key_hash, timelock_period) from data.json
    data = load_data_json(pub_hash=True, timelock_csv=True, timelock_log=True)
    pub_key_hash, timelock_period = data['pub_key_hash'], data['timelock_csv']
    timelock_str = data['timelock_log']

    csv_script = Script([timelock_period, 'OP_CHECKSEQUENCEVERIFY', 'OP_DROP',
        'OP_DUP', 'OP_HASH160', pub_key_hash, 'OP_EQUALVERIFY', 'OP_CHECKSIG'])
    # get P2SH address of csv_script
    p2sh_addr = P2shAddress.from_script(csv_script).to_address()
    csv_hash = csv_script.to_hex()

    if recreate:  # used when spending from p2sh
       return csv_script, p2sh_addr
    
    # used when creating initial p2sh
    # - writes p2sh address into data.json
    # - displays p2sh address (+details) to the user
    update_data_json({'p2sh_address': p2sh_addr, 'csv_hash': csv_hash})
    print('\nNew p2sh address with CSV script created')
    print(' -> timelock period for:', timelock_str)
    print(' -> script_hash:', csv_hash)
    print(' -> p2sh_addr:', p2sh_addr, '\n')


def create_csv_spending_transaction():
    """creates a transaction to spend all funds from the P2SH address,
    broadcasts the transaction to network via bitcoin-cli (os communicaiton)
    """
    # loads script data (Script, p2sh_addr)
    csv_script, p2sh_addr = create_csv_script_p2sh(recreate=True)

    # load transaction data(PrivateKey, timelock, P2pkhAddresses) from data.json
    data = load_data_json(priv=True, timelock_tx=True, p2pk=True)
    priv_key, tx_lock = data['priv_key'], data['timelock_tx'] 
    p2pkh_addr = data['p2pk_addr']

    # query cli to detect transactions send to the p2sh adddress
    # gathers txid, vout, and amount of p2sh's UTXOs to create TxInputs
    p2sh_utxos, p2sh_balance = [], 0
    wallet_txs = talk_to_cli('bitcoin-cli listtransactions * 900', True)
    for tx in json.loads(wallet_txs):
        if tx['address'] == p2sh_addr and tx['category'] == 'send':
            p2sh_utxos.append(TxInput(tx['txid'], tx['vout'], sequence=tx_lock))
            p2sh_balance += (-tx['amount'])
    # confirm that bitcoin-cli was able to locate transactions to p2sh address
    if not p2sh_utxos:
        print('\nError: local bitcoin-cli has no record of p2sh inputs!')
        print('It appears that the transactions to the p2sh address have been')
        print('created from a different bitcoin client. Please send some BTC')
        print('to the p2sh address from the local bitcoin-cli client')
        raise SystemExit

    # check current network fees and compute fee estimate
    resp = requests.get('https://api.blockcypher.com/v1/btc/test3').json()
    fee_per_kb = resp['medium_fee_per_kb']
    # per Output: 34 bytes | per Input: 200 bytes (estimate)
    script_size = 1 * 34 + len(p2sh_utxos) * 200
    fee = (script_size * fee_per_kb) / 100000000
    if fee >= p2sh_balance:
        fee = user_custom_fee(fee, p2sh_balance)        

    # create and sign transaction
    tx_out = TxOutput((p2sh_balance-fee), p2pkh_addr.to_script_pub_key())
    # no change address, spending entire balance
    tx = Transaction(p2sh_utxos, [tx_out])
    pub_key = priv_key.get_public_key().to_hex()
    for i, txin in enumerate(p2sh_utxos):
        sig = priv_key.sign_input(tx, i, csv_script)
        txin.script_sig = Script([sig, pub_key, csv_script.to_hex()])
    tx_signed, tx_id = tx.serialize(), tx.get_txid()
    """
    The issue is that you do not set the public key when setting the script_sig 
    (line 265). You need the script (which you have) and the P2PKH unlocking 
    script (which is sig plus pubkey).
    """

    # writes tx_id into data.json and displays tx_signed (+details) to the user
    update_data_json({'tx_id': tx_id, 'tx_signed': tx_signed})
    print('\n Spending from P2SH transaction')
    print(' -> to_addr:', p2pkh_addr.to_address())
    print(' -> amount:', p2sh_balance-fee)
    print(' -> fee:', fee)
    print(' -> tx_id:', tx_id)
    print(' -> tx_signed',tx_signed)

    # broadcast signed transaction over bitcoin-cli
    r = talk_to_cli(f'bitcoin-cli sendrawtransaction {tx_signed}')
    if r == 0:
        print('\nTransaction broadcasted via bitcoin-cli')


if __name__ == '__main__':
    def missing_mode():
        """helper function called when script is run with invalid mode"""
        print('\nError: No valid mode specified!')
        print('Please specify mode as follows:')
        print('-------------------------------')
        print('- To create a p2sh address:')
        print('  $ python3 main.py create_p2sh\n')
        print('- To spend from p2sh address:')
        print('  $ python3 main.py spend_p2sh\n')
        raise SystemExit

    try:  # get script argument (mode)
        mode = sys.argv[1]
    except:
        missing_mode()

    # ensure that bitcoind is running
    r1 = os.system('bitcoin-cli ping')
    if r1 != 0:
        print('Starting bitcoin client')
        r2 = os.system('bitcoind -daemon')
        if r2 != 0:
            print('Error: Unable to start bitcoind, pls manually start/install')
            raise SystemExit
        print('Waiting for blocks to rewind...\n')
        while True:
            r3 = os.system('bitcoin-cli ping')
            if r3 == 0:
                break
            sleep(1)

    # run function of mode
    run = {'create_p2sh': create_csv_script_p2sh,
           'spend_p2sh': create_csv_spending_transaction}
    if mode in run:
        setup('testnet')
        run[mode]()
    else:
        missing_mode()
